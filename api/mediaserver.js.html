<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>mediaserver.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Conference.html">Conference</a><ul class='methods'><li data-type='method'><a href="Conference.html#agc">agc</a></li><li data-type='method'><a href="Conference.html#chkRecord">chkRecord</a></li><li data-type='method'><a href="Conference.html#deafAll">deafAll</a></li><li data-type='method'><a href="Conference.html#destroy">destroy</a></li><li data-type='method'><a href="Conference.html#lock">lock</a></li><li data-type='method'><a href="Conference.html#muteAll">muteAll</a></li><li data-type='method'><a href="Conference.html#pauseRecording">pauseRecording</a></li><li data-type='method'><a href="Conference.html#play">play</a></li><li data-type='method'><a href="Conference.html#resumeRecording">resumeRecording</a></li><li data-type='method'><a href="Conference.html#startRecording">startRecording</a></li><li data-type='method'><a href="Conference.html#stopRecording">stopRecording</a></li><li data-type='method'><a href="Conference.html#unlock">unlock</a></li></ul></li><li><a href="ConferenceConnection.html">ConferenceConnection</a><ul class='methods'><li data-type='method'><a href="ConferenceConnection.html#deaf">deaf</a></li><li data-type='method'><a href="ConferenceConnection.html#kick">kick</a></li><li data-type='method'><a href="ConferenceConnection.html#mute">mute</a></li><li data-type='method'><a href="ConferenceConnection.html#play">play</a></li><li data-type='method'><a href="ConferenceConnection.html#transfer">transfer</a></li></ul></li><li><a href="Endpoint.html">Endpoint</a><ul class='methods'><li data-type='method'><a href="Endpoint.html#api">api</a></li><li data-type='method'><a href="Endpoint.html#connected">connected</a></li><li data-type='method'><a href="Endpoint.html#destroy">destroy</a></li><li data-type='method'><a href="Endpoint.html#execute">execute</a></li><li data-type='method'><a href="Endpoint.html#joinConference">joinConference</a></li><li data-type='method'><a href="Endpoint.html#modifySession">modifySession</a></li><li data-type='method'><a href="Endpoint.html#play">play</a></li><li data-type='method'><a href="Endpoint.html#playCollect">playCollect</a></li><li data-type='method'><a href="Endpoint.html#say">say</a></li></ul></li><li><a href="MediaServer.html">MediaServer</a><ul class='methods'><li data-type='method'><a href="MediaServer.html#api">api</a></li><li data-type='method'><a href="MediaServer.html#connectCaller">connectCaller</a></li><li data-type='method'><a href="MediaServer.html#connected">connected</a></li><li data-type='method'><a href="MediaServer.html#createConference">createConference</a></li><li data-type='method'><a href="MediaServer.html#createEndpoint">createEndpoint</a></li><li data-type='method'><a href="MediaServer.html#disconnect">disconnect</a></li></ul></li><li><a href="Mrf.html">Mrf</a><ul class='methods'><li data-type='method'><a href="Mrf.html#connect">connect</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="Endpoint.html#event:destroy">destroy</a></li><li><a href="MediaServer.html#event:connect">connect</a></li><li><a href="MediaServer.html#event:error">error</a></li><li><a href="MediaServer.html#event:ready">ready</a></li><li><a href="Mrf.html#event:error">error</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">mediaserver.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var esl = require('modesl') ;
var assert = require('assert') ;
var delegate = require('delegates') ;
var Emitter = require('events').EventEmitter ;
var util = require('util') ;
var _ = require('lodash') ;
var only = require('only') ;
var async = require('async') ;
var generateUuid = require('node-uuid') ;
var Endpoint = require('./endpoint') ;
var Conference = require('./conference'); 
var nullSdp = require('../data/nullsdp') ;
var fs = require('fs') ;
var path = require('path') ;
var debug = require('debug')('drachtio-fsmrf') ;

/**
 * A freeswitch-based media-processing resource that contains Endpoints and Conferences.
 * @constructor
 * @param {esl.Connection} conn   inbound connection to freeswitch event socket   
 * @param {Mrf} mrf               media resource function that instantiated this MediaServer   
 * @param {object} app            drachtio app
 * @param {number} listenPort     tcp port to listen on for outbound event socket connections
 *
 * @fires MediaServer#connect
 * @fires MediaServer#ready
 * @fires MediaServer#error
 */
function MediaServer( conn, mrf, app, listenPort ) {
  Emitter.call(this); 

  var self = this ;
  this._conn = conn ;
  this._mrf = mrf ;
  this._app = app ;
  this._srf = mrf.srf ;
  this.pendingConnections = {} ;

  //these will be udpated every 20 seconds by the HEARTBEAT event messages
  
  /**
   * maximum number of active Endpoints allowed on the MediaServer
   * @type {Number}
   */
  this.maxSessions = 0 ;
  /**
   * current number of active Endpoints on the MediaServer
   * @type {Number}
   */
  this.currentSessions = 0 ;
  /**
   * current calls per second on the MediaServer
   * @type {Number}
   */
  this.cps = 0 ;


  if( mrf.debugDir ) {
    this.logger = fs.createWriteStream(path.join(mrf.debugDir, 'mediaserver-' + conn.socket.address().address + '.txt' ) ) ;
    var origWrite = conn.socket.write ;
    conn.socket.write = function(data) {
      this.emit.call(this, 'write', data) ;
      return origWrite.apply( this, arguments) ;
    } ;

    conn.socket.on('data', this._onSocketRead.bind( this ) ) ;
    conn.socket.on('write', this._onSocketWrite.bind( this ) ) ;
  }

  this._conn.subscribe(['HEARTBEAT']) ;
  this._conn.on('esl::event::HEARTBEAT::*', this._onHeartbeat.bind(this)) ;
  this._conn.on('error', this._onError.bind(this));

  //create the server (outbound connections) 
  this._server = new esl.Server({port: listenPort, myevents:false}, function() {
    self.emit('connect') ;

    // find out the sip address and port the media server is listening on
    self._conn.api('sofia status', function(res){
      var status = res.getBody() ;
      var re = /^\s*drachtio_mrf\s.*sip:mod_sofia@((?:[0-9]{1,3}\.){3}[0-9]{1,3}):(\d+)/m ;
      var results = re.exec( status ) ;
      if( null === results ) { throw new Error('No drachtio_mrf sip profile found on the media server: ' + status);}
      self.sipAddress = results[1] ;
      self.sipPort = parseInt( results[2] ) ;
      self.emit('ready') ;
    }) ;

  });   
  this._server.on('connection::ready', self._onNewCall.bind(self)) ;     

}
util.inherits(MediaServer, Emitter) ;
module.exports = exports = MediaServer ;

/**
 * Close the inbound event socket connection
 */
MediaServer.prototype.disconnect = function() {
  this._conn.disconnect() ;
} ;

/**
 * send an api command to the freeswitch server
 * @param  {string}   command command to execute
 * @param  {MediaServer~apiCallback} cb      callback that handles the response
 */
MediaServer.prototype.api = function(command, cb) {
  assert(typeof command, 'string', '\'command\' must be a valid freeswitch api command') ;
  assert(typeof cb, 'function', 'callback must be provided') ;

  this._conn.api(command, function(res) {
    cb(res.getBody()) ;
  }) ;
} ;
/**
 * This callback provides the response to an api request.
 * @callback MediaServer~apiCallback
 * @param {string} body of the response message
 */

/**
 * allocate an Endpoint on the MediaServer, optionally allocating a media session to stream to a 
 * remote far end SDP (session description protocol).  If no far end SDP is provided, the endpoint
 * is initially created in the inactive state.
 * @param  {MediaServer~EndpointOptions}   [opts] - create options
 * @param  {MediaServer~createEndpointCallback} cb   callback that provides error or Endpoint
 */
MediaServer.prototype.createEndpoint = function( opts, cb ) {
  var self = this ;
  if( typeof opts === 'function' ) {
    cb = opts ;
    opts = {} ;
  }
  assert.ok(typeof cb === 'function', 'callback was not provided') ;
  assert.ok(typeof opts === 'object', 'opts param must be an object') ;

  if( !this.connected() ) { 
    process.nextTick( function() {
      cb(new Error('too early: mediaserver is not connected')) ;
    }) ;
    return ;
  }
  if( !this.sipAddress ) {
    process.nextTick( function() {
      cb(new Error('too early: mediaserver is not ready')) ;
    }) ;   
    return ; 
  }

  if( !opts.remoteSdp ) {
    var arr = /^(.*):?(.*)$/g.exec( this._app.get('hostport') ) ;
    opts.remoteSdp = nullSdp(arr[1], '16000') ;
  }

  // generate a unique id to track the endpoint during creation 
  var uuid = generateUuid.v4() ;
  this.pendingConnections[uuid] = {
    callback: cb,
    createTimeout: setTimeout( this._onCreateTimeout.bind(this, uuid) , 120000 ),
    opts: {
      codecs: opts.codecs || []
    },
    dialog: null
  } ;

  // launch an INVITE towards the media server 
  var uri = 'sip:drachtio@' + this.sipAddress + ':' + this.sipPort ;
  this._srf.createUacDialog( uri, {
    headers: {
      'User-Agent': 'drachtio-fsmrf:' + uuid
    },
    localSdp: opts.remoteSdp
  }, function(err, dialog) {
    if( err ) { 
      delete self.pendingConnections[uuid] ;
      return cb( new Error( '' + err.status + ' ' + err.reason) ); 
    }

    //success!
    debug('MediaServer#createEndpoint - endpoint created') ;
    var obj = self.pendingConnections[uuid] ;
    obj.ep.dialog = dialog ;
    clearTimeout( obj.createTimeout ) ;
    delete self.pendingConnections[uuid] ;
  }) ;
} ;
/**
 * This callback provides the response to an attempt to create an Endpoint on the MediaServer.
 * @callback MediaServer~createEndpointCallback
 * @param {Error} error encountered while attempting to create the endpoint
 * @param {Endpoint} endpoint that was created
 */

/**
 * connects an incoming call to the media server, producing both an Endpoint and a SIP Dialog upon success
 * @param  {Object}   req  - drachtio request object for incoming call
 * @param  {Object}   res  - drachtio response object for incoming call
 * @param  {MediaServer~EndpointOptions}   [opts] - options for creating endpoint and responding to caller
  * @param  {MediaServer~connectCallerCallback} cb   callback invoked on completion of operation
*/
MediaServer.prototype.connectCaller = function(req, res, opts, cb) {
  var self = this ;
  if( typeof opts === 'function' ) {
    cb = opts ;
    opts = {} ;
  }

  async.waterfall([
      function createEndpoint(callback) {
        self.createEndpoint({
          remoteSdp: req.body,
          codecs: opts.codecs 
        }, callback) ;
      },
      function respondToCaller(ep, callback) {
        self._srf.createUasDialog(req, res, {
          localSdp: ep.local.sdp,
          headers: opts.headers
        }, function(err, dialog) {
          if( err ) { return callback(err);}
          callback(null, ep, dialog) ;
        }) ;
      }
    ], function(err, ep, dialog) {
      cb(err, ep, dialog) ;
  }) ;
} ;
/**
 * This callback provides the response to an attempt connect a caller to the MediaServer.
 * @callback MediaServer~connectCallerCallback
 * @param {Error} err - error encountered while attempting to create the endpoint
 * @param {Endpoint} ep - endpoint that was created
 * @param {Dialog} dialog - sip dialog that was created
 */

/**
 * creates a conference on the media server.
 * @param  {String}   name - conference name
 * @param {Conference~createOptions}  [opts] - conference-level configuration options
 * @param {Conference~createCallback} cb - callback invoked when conference is created
 */
MediaServer.prototype.createConference = function( name, opts, cb ) {
  var self = this ;
  if( typeof opts === 'function' ) {
    cb = opts ;
    opts = {} ;
  }
  assert.equal( typeof name, 'string', '\'name\' is a required parameter') ;
  assert.ok(typeof cb === 'function', 'callback was not provided') ;
  assert.ok(typeof opts === 'object', 'opts param must be an object') ;

  /* Steps for creating a conference:
     (1) Check to see if a conference of that name already exists - return error if so
     (2) Create the conference  control leg (endpoint)
     (3) Create the conference
  */
 
  async.waterfall([
    function doesConfExist(callback) {
      self.api('conference ' + name + ' list count', function(result) {
        debug('return from conference list: ', result) ;
        if( typeof result === 'string' &amp;&amp; (result.match(/^No active conferences/) || result.match(/^Conference.*not found/) ) ) {
          return callback(null) ;
        }
        callback(null) ;
        //callback('conference exists') ;
      }); 
    },
    function createControlLeg(callback) {
      self.createEndpoint({}, function(err, endpoint) {
        if( err ) { return callback(err); }
        callback(null, endpoint) ;
      }); 
    },
    function createConference(endpoint, callback) {
      new Conference(endpoint, name, opts, function(err, conference) {
        if(err) { return callback(err); }
        callback( null, endpoint, conference); 
      }) ;
    } 
    ], function(err, endpoint, conference) {
      if( err ) { return cb(err); }
      debug('endpoint: ', JSON.stringify(endpoint)) ;
      debug('conference: ', JSON.stringify(conference)) ;

      cb(null, conference) ;
    }
  ) ;
} ;

MediaServer.prototype.toJSON = function() {
  return( only( this, 'sipAddress sipPort maxSessions currentSessions cps cpuIdle fsVersion hostname v4address pendingConnections')) ;
} ;

MediaServer.prototype._onError = function(err) {
  this.emit('error', err);
};
MediaServer.prototype._onHeartbeat = function(evt) {
  this.maxSessions = parseInt( evt.getHeader('Max-Sessions')) ;
  this.currentSessions = parseInt( evt.getHeader('Session-Count')) ;
  this.cps = parseInt( evt.getHeader('Session-Per-Sec')) ;
  this.hostname = evt.getHeader('FreeSWITCH-Hostname') ;
  this.v4address = evt.getHeader('FreeSWITCH-IPv4') ;
  this.v6address = evt.getHeader('FreeSWITCH-IPv6') ;
  this.fsVersion = evt.getHeader('FreeSWITCH-Version') ;
  this.cpuIdle = parseFloat( evt.getHeader('Idle-CPU')) ;
} ;
MediaServer.prototype._onCreateTimeout = function( uuid ) {
  if( !(uuid in this.pendingConnections ) ) {
    console.error('MediaServer#_onCreateTimeout: uuid not found: %s', uuid) ;
    return ;
  }
  var obj = this.pendingConnections[uuid] ;
  obj.callback('Connection timeout') ;
  clearTimeout( obj.createTimeout ) ;

  delete this.pendingConnections[uuid] ;

  console.log('createEndpoint %s timed out; after removing there are %d Endpoints in pending create state', 
    uuid, _.keys(this.pendingConnections).length) ;
} ;

//new outbound event socket connection
MediaServer.prototype._onNewCall = function(conn /*, id */) {
  var self = this ;
  var userAgent = conn.getInfo().getHeader('variable_sip_user_agent') ;

  var re = /^drachtio-fsmrf:(.+)$/ ;
  var results = re.exec(userAgent) ;
  if( null === results ) {
    console.error('received INVITE without drachtio-fsmrf header, unexpected User-Agent: %s', userAgent) ;
    return conn.execute('hangup', 'NO_ROUTE_DESTINATION') ;
  }
  var uuid = results[1] ;
  if( !uuid || !(uuid in this.pendingConnections ) ) {
    console.error('received INVITE with unknown uuid: %s', uuid) ;
    return conn.execute('hangup', 'NO_ROUTE_DESTINATION') ;    
  }

  debug('created new endpoint') ;
  var obj = this.pendingConnections[uuid] ;
  if( this._mrf.debugDir ) {
    _.extend( obj.opts, {debugDir: this._mrf.debugDir}) ;
  }
  obj.ep = new Endpoint( conn, self, self._app, obj.opts, obj.callback) ; 
} ;

MediaServer.prototype._onSocketRead = function(data) {
  this.logger.write('&lt;= ' + data.toString(), 'utf8') ;
} ;
MediaServer.prototype._onSocketWrite = function(data) {
  this.logger.write('=> ' + data.toString(), 'utf8') ;
} ;


/** returns true if the MediaServer is in the 'connected' state
*   @name MediaServer#connected
*   @method
*/

delegate(MediaServer.prototype, '_conn')
  .method('connected') ;


/**
 * Arguments provided when creating an Endpoint on a MediaServer
 * @typedef {Object} MediaServer~EndpointOptions
 * @property {String} [remoteSdp] remote session description protocol (if not provided, an initially inactive Endpoint will be created)
 * @property {String[]} [codecs] - array of codecs, in preferred order (e.g. ['PCMU','G722','PCMA'])
 */

/**
 * connect event triggered when connection is made to the freeswitch media server.
 * @event MediaServer#connect
 */
/**
 * ready event triggered after connecting to the server and verifying it is properly configured and ready to accept calls.
 * @event MediaServer#ready
 */
/**
 * Error event triggered when connection to freeswitch media server fails.
 *
 * @event MediaServer#error
 * @type {object}
 * @property {String} message - Indicates the reason the connection failed
 */

</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Nov 23 2015 21:59:11 GMT-0500 (EST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
