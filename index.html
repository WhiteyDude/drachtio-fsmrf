<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Drachtio-fsmrf by davehorton</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">drachtio-fsmrf</h1>
      <h2 class="project-tagline">drachtio media resource function</h2>
      <a href="https://github.com/davehorton/drachtio-fsmrf" class="btn">View on GitHub</a>
      <a href="https://github.com/davehorton/drachtio-fsmrf/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/davehorton/drachtio-fsmrf/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <div class="drachtio-img"><img src="http://davehorton.github.io/drachtio-fsmrf/img/definition-only-cropped.png">
      </div>
      <p>
        Welcome to the Drachtio Media Resource framework, a partner module to <a href="http://davehorton.github.io/drachtio-srf">drachtio-srf</a> for building high-performance <a href="SIP">https://www.ietf.org/rfc/rfc3261.txt</a>.
      </p>
      <p>
        drachtio-fsmrf implements common media server functions on top of Freeswitch and enables rich media applications involving IVR, conferencing and other features to be built in pure javascript without requiring in-depth knowledge of freeswitch configuration.
      </p>
      <p>
        <strong>Note:</strong>&nbsp;drachtio-fsmrf applications require a freeswitch media server, configured as per <a href="https://cloud.docker.com/swarm/drachtio/repository/docker/drachtio/drachtio-freeswitch-mrf/general">drachtio/drachtio-freeswitch-mrf</a>.  To build your own properly-configured Freeswitch to use with this module, either review that Dockerfile or have a look at <a href="https://github.com/davehorton/drachtio-mrf-ansible">drachtio-mrf-ansible</a>.
      </p>
      <p><a href="http://davehorton.github.io/drachtio-fsmrf/api/index.html">API documentation for drachtio-fsmrf can be found here</a></p>
      <h1>Data Model</h1>
      <p>This module exports a single class, <strong>Mrf</strong> (aka Media Resource Framework).</p>
      <p>
        Invoking the constructor creates an instance of the Mrf class that can then be used to connect to <strong>Mediaservers</strong>; once connected to a Mediaserver you can create and manipulate instances of <strong>Endpoints</strong> and <strong>Conferences</strong>.
      </p>
      <p>
        That's it -- those are all the classes you need to work with. You can connect calls to a Mediaserver, producing an Endpoint.  You can then perform operations like <i>play</i>, <i>say</i>, <i>bridge</i>, <i>park</i> etc on the Endpoint (which equates to a Freeswitch channel).  You can create Conferences, join Endpoints into Conferences, and perform operations on the Conference.  And you can call any of the myriad freeswitch applications or api methods via the Endpoint and Conference classes.        
      </p>
      <p>
        Let's dive in.
      </p>
      
      <h1>Getting Started</h1>
      <p>
        First, create an instance of both the drachtio signaling resource framework and the media resource framework, as per below.
      </p>
      <pre>
const Srf = require('drachtio-srf');
const Mrf = require('drachtio-fsmrf');

const srf = new Srf() ;
srf.connect(host: '127.0.0.1');

srf.on('connect', (err, hostport) => {
  console.log(`successfully connected to drachtio listening on ${hostport}`);
});

const mrf = new Mrf(srf) ;        
      </pre>
      <p>
        At that point, the mrf instance can be used to connect to and produce instances of MediaServers
      </p>
      <pre>
mrf.connect({address: '127.0.0.1', port: 8021, secret: 'ClueCon'})
  .then((mediaserver) => {
    console.log('successfully connected to mediaserver');
  })
  .catch ((err) => {
    console.error(`error connecting to mediaserver: ${err}`);
  });
      </pre>
      <p>
        In the example above, we see the `mrf#connect` method returns a Promise that resolves with an instance of the media server.  As with all public methods, a callback variant is available as well:
      </p>
      <pre>
// we're connecting to the Freeswitch event socket
mrf.connect({address: '127.0.0.1', port: 8021, secret: 'ClueCon'}, (err, mediaserver) => {
    if (err) {
      return console.log(`error connecting to mediaserver: ${err}`);
    }
    console.log(`connected to mediaserver listening on ${JSON.stringify(ms.sip)}`);
    /*
      {
        "ipv4": {
          "udp": {
            "address":"172.28.0.11:5060"
          },
          "dtls": {
            "address":"172.28.0.11:5081"
          }
        },
        "ipv6":{
          "udp":{},
          "dtls":{}
        }
      }
    */
  }
});        
      </pre>
      <p>
        Having a media server instance, we can now create instances of Endpoints and Conferences and invoke operations on those objects.
      </p>
      <h1>Performing Media Operations</h1>
      <p>
        We can create an Endpoint when we have an incoming call, by connecting it to a Mediaserver.
      </p>
      <pre>
srf.invite((req, res) => {
  mediaserver.connectCaller(req, res)
    .then(({endpoint, dialog}) => {
      console.log('successfully connected call to media server');
    });
      </pre>
      <p>
        In the example above, we use <code>MediaServer#connectCaller()</code> to connect a call to a Mediaserver, producing both an <strong>Endpoint</strong> (represening the channel on Freeswitch) and a <strong>Dialog</strong> (representing the UAS dialog).
      </p>
      <p>
        Again, note that a callback version is also available:        
      </p>
      <pre>
srf.invite((req, res) => {   
  mediaserver.connectCaller(req, res, (err, {endpoint, dialog} => {
    if (err) return console.log(`Error connecting ${err}`);
    console.log('successfully connected call to media server');
  });        
      </pre>
      <p>
        We can also create an Endpoint outside of any inbound call by calling <code>MediaServer#createEndpoint()</code>.  This will give us an initially inactive Endpoint that we can later modify to stream to a remote destination:
      </p>
      <pre>
mediaserver.createEndpoint()
  .then((endpoint) => {

    // some time later...
    endpoint.modify(remoteSdp);

  });        
      </pre>
      <p>
        Once we have an Endpoint, we can do things like play a prompt and collect dtmf:
      </p>
      <pre>
endpoint.playCollect({file: myFile, min: 1, max: 4})
  .then((obj) => {
    console.log(`collected digits: ${obj.digits}`);
  });        
      </pre>
      <p>
        Conferences work similarly - we create them and then can join Endpoints to them.
      </p>
      <pre>
mediaserver.createConference('my_conf', {maxMembers: 50})
  .then((conference) => {
    return endpoint.join(conference)
  })
  .then(() => {
    console.log('endpoint joined to conference')
  });
      </pre>
      <p>
        When an Endpoint is joined to a Conference, we have an additional set of operations we can invoke on the Endpoint -- things like mute/unmute, turn on or off automatic gain control, playing a file directly to the participant on that Endpoint, etc.  These actions are performed by methods that all begin with <i>conf</i>:
      </p>
      <pre>
endpoint.join(conference, (err) => {
  if (err) return console.log(`Error ${err}`);

  endpoint.confMute();
  endpoint.confPlay(myFile);
}        
      </pre>
      <h1>Execute any Freeswitch application or api</h1>
      <p>
        As shown above, some methods have been added to the <code>Endpoint</code> and <code>Conference</code> class to provide syntactic sugar over freeswitch aplications and apis.  However, any Freeswitch application or api can also be called directly.
      </p>
      <p>
        <code>Endpoint#execute</code> executes a Freeswitch application and returns in either the callback or the Prompise the contents of the associated CHANNEL_EXECUTE_COMPLETE event that Freeswitch returns. The event structure <a href="https://github.com/englercj/node-esl/blob/master/lib/esl/Event.js">is defined here</a>.
      </p>
      <pre>
// use freeswitch application to generate dtmf from an Endpoint
endpoint.execute('send_dtmf', `${digits}@125`, (err, evt) => {
  if (err) return console.error(err);

  console.log(`last dtmf duration was ${evt.getHeader('variable_last_dtmf_duration')}`);
})        
      </pre>
      <p>
        <code>Endpoint#api</code> executes a Freeswitch api call and returns in either the callback or the Promise the response that Freeswitch returns to the command.  
      </p>
      <pre>
// use freeswitch api to get all current channel variables
endpoint.api('uuid_dump', endpoint.uuid)
  .then((response) => {
    console.log(`${JSON.stringify(response)}`);
    //
    //    {
    //  "headers": [{
    //    "name": "Content-Type",
    //    "value": "api/response"
    //  }, {
    //    "name": "Content-Length",
    //    "value": 8475
    //  }],
    //  "hPtr": null,
    //  "body": "Event-Name: CHANNEL_DATA\n..

  });        
      </pre>
      <p>
        Note that Content-Type api/response returned by api requests return a body consisting of plain text separated by newlines. To parse this body into a plain javascript object with named properties, use the `Mrf#utils#parseBodyText` method, as per below:
      </p>
      <pre>
// use parseBodyText to parse api headers into simple object properties
endpoint.api('uuid_dump', endpoint.uuid)
  .then((evt) => {
    const vars = Mrf.utils.parseBodyText(evt.getBody());
    console.log(`${JSON.stringify(vars)}`);
    //   {
    //    "Event-Name": "CHANNEL_DATA",
    //    "Core-UUID": "de006bc8-f892-11e7-a989-3b397b4b8083",
    //     ...
    //   }
  });        
      </pre>

    <h1>Tests</h1>
    <p>
      To run tests you will need Docker and docker-compose installed on your host, as the test suite runs in a docker network created by <a href="https://github.com/davehorton/drachtio-fsmrf/blob/master/test/docker-compose-testbed.yaml">docker-compose-testbed.yaml</a>.  The first time you run the tests, it will take a while since docker images will be downloaded to your host.
    </p>
    <pre>
$ npm test

starting docker network..

docker network started, giving extra time for freeswitch to initialize...

Mrf#connect using Promise

✔ mrf.localAddresses is an array
✔ socket connected
✔ mediaserver.srf is an Srf

...etc...
    </pre>



    <h1>License</h1>
      <a href="https://github.com/davehorton/drachtio-fsmrf/blob/master/LICENSE">MIT</a>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/davehorton/drachtio-fsmrf">drachtio-fsmrf</a> is maintained by <a href="https://github.com/davehorton">davehorton</a>.</span>
      </footer>

    </section>

  </body>
</html>
